<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polynomials · Exercises in writing macros for Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Exercises in writing macros for Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Exercises in macro writing</a></li><li class="is-active"><a class="tocitem" href>Polynomials</a><ul class="internal"><li><a class="tocitem" href="#Horner&#39;s-method"><span>Horner&#39;s method</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jhidding/MacroExercises.jl/blob/main/docs/jl_Tu2uyu/src/polynomials.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Polynomials"><a class="docs-heading-anchor" href="#Polynomials">Polynomials</a><a id="Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials" title="Permalink"></a></h1><p>If you&#39;re not sold on macros for their expressiveness, here&#39;s something new for you. One reason why macros can be so powerful, is that they let us write little code generators for things that we normally wouldn&#39;t bother with. This means getting potentially huge performance gains. We&#39;ll work through an example where we need to compute some polynomial.</p><div class="noweb-label">file:<i>src/Polynomials.jl</i></div><pre><code class="language- julia hljs">module Polynomials
&lt;&lt;polynomials&gt;&gt;
end</code></pre><p>A polynomial is a function defined by some finite power series,</p><p class="math-container">\[f(x) = \sum_{i = 0}^{n} c_i x^i,\]</p><p>where we refer to <span>$c_i$</span> as the coefficients of the polynomial. We may store a polynomial as a Vector.</p><div class="noweb-label">⪡polynomials⪢≣</div><pre><code class="language- julia hljs">struct Polynomial{T}
    c::Vector{T}
end

function Polynomial(c::T...) where T&lt;:Number
    Polynomial(T[c...])
end

function compute_vectorized(f::Polynomial{T}, x::T) where T&lt;:Number
    sum(f.c .* x.^(0:(length(f.c)-1)))
end</code></pre><p>The notation in <code>compute_vectorized</code> is very compact, and it closely mimics the actual function definition that we gave for a polynomial. Is it also fast?</p><pre><code class="language-julia hljs">using MacroExercises.Polynomials: Polynomial, compute_vectorized, compute_tight_loop

f = Polynomial(1.0, -3.0, 2.0, -4.0, 1.5, 0.3, -0.1)
xs = LinRange(0.0, 1.0, 100000)

test_f1(n) = for _ in 1:n
    xs .|&gt; x -&gt; compute_vectorized(f, x)
end

# compile
test_f1(1)

# time
@elapsed test_f1(100)</code></pre><p>On my machine this takes about two seconds. A profiler reveals that most time (about 70%) is spent computing the <code>:^</code> function. We can be more efficient if we use incremental multiplication.</p><div class="noweb-label">⪡polynomials⪢⊞</div><pre><code class="language- julia hljs">function compute_tight_loop(f::Polynomial{T}, x::T) where T&lt;:Number
    result = 0
    xpow = 1
    for c in f.c
        result += xpow * c
        xpow *= x
    end
    result
end</code></pre><pre><code class="language-julia hljs">test_f2(n) = for _ in 1:n
    xs .|&gt; x -&gt; compute_tight_loop(f, x)
end

test_f2(1)

@elapsed test_f2(1000)</code></pre><p>This takes about three seconds on my machine, so the tight loop version is an order of magnitude faster (note the sample size). Can we do better? Now it starts to get interesting! We&#39;ll generate code as if we unroll the for-loop for a specific case of a polynomial manualy.</p><div class="noweb-label">⪡polynomials⪢⊞</div><pre><code class="language- julia hljs">function expand(f::Polynomial{T}) where T&lt;:Number
    :(function (x::$T)
        r = $(f.c[1])
        xp = x
        $((:(r += xp*$c; xp*=x) for c in f.c[2:end-1])...)
        r + xp * $(f.c[end])
    end)
end</code></pre><p>What does that generated code look like?</p><pre><code class="language-julia hljs">using MacroExercises.Polynomials: Polynomial, expand

Base.remove_linenums!(
    expand(Polynomial(1.0, 0.5, 0.333, 0.25)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">:(function (x::Float64,)
      r = 1.0
      xp = x
      begin
          r += xp * 0.5
          xp *= x
      end
      begin
          r += xp * 0.333
          xp *= x
      end
      r + xp * 0.25
  end)</code></pre><p>Now, test it for speed:</p><pre><code class="language-julia hljs">f_unroll = eval(expand(f))
test_f3(n) = sum(sum(f_unroll.(xs)) for _ in 1:n)
test_f3(1)
@elapsed test_f3(1000)</code></pre><p>For me this computes in 0.12 seconds. That is 25 times faster than the dynamic <code>tight_loop</code> version. I think that is really amazing. For reference, here is the C++ equivalent of the tight loop version. I had to try really hard to make it not optimize away results that weren&#39;t used afterwards.</p><div class="noweb-label">file:<i>src/polynomials.cpp</i></div><pre><code class="language- cpp hljs">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

double compute_tight_loop(std::vector&lt;double&gt; const &amp;cs, double x) {
    double r = 0.0;
    double xp = 1.0;
    for (auto c : cs) {
        r += xp * c;
        xp *= x;
    }
    return r;
}

int main() {
    using std::chrono::duration_cast;
    using std::chrono::milliseconds;
    using std::accumulate;

    std::vector&lt;double&gt; c{1.0, -3.0, 2.0, -4.0, 1.5, 0.3, -0.1};
    std::cout &lt;&lt; compute_tight_loop(c, 10.0) &lt;&lt; std::endl;
    std::vector&lt;double&gt; input(100000), output(100000);
    for (unsigned i = 0; i &lt; 100000; ++i) { input[i] = i / 100000.0; }
    auto start = std::chrono::high_resolution_clock::now();
    double grant_total = 0.0;
    for (unsigned i = 0; i &lt; 1000; ++i) {
        for (unsigned j = 0; j &lt; 100000; ++j) { output[j] = compute_tight_loop(c, input[j]); }
        grant_total += accumulate(output.begin(), output.end(), 0.0);
    }
    auto stop = std::chrono::high_resolution_clock::now();
    std::cout &lt;&lt; &quot;total: &quot; &lt;&lt; grant_total &lt;&lt; std::endl
              &lt;&lt; &quot;duration: &quot; &lt;&lt; duration_cast&lt;milliseconds&gt;(stop - start) &lt;&lt; std::endl;
    return 0;
}</code></pre><p>This gives me about 300ms on my laptop, against 120ms for the Julia version. So how could Julia be faster than C++? We were able to compile our polynomial code for a specific polynomial on the fly, creating a function that does not need to access memory. The equivalent in C++ would be to generate code and pass that through GCC and then run it: that is insane.</p><h2 id="Horner&#39;s-method"><a class="docs-heading-anchor" href="#Horner&#39;s-method">Horner&#39;s method</a><a id="Horner&#39;s-method-1"></a><a class="docs-heading-anchor-permalink" href="#Horner&#39;s-method" title="Permalink"></a></h2><p>There is a more efficient way to evaluate a polynomial, called Horner&#39;s method (thanks Nicos Pitsianis for pointing it out to me). Let&#39;s implement it and compare. The method works by starting at the highest order coefficient.</p><div class="noweb-label">⪡polynomials⪢⊞</div><pre><code class="language- julia hljs">function horner(f::Polynomial{T}) where T&lt;:Number
    r = :($(f.c[end]))
    for c in reverse(f.c[1:end-1])
        r = :($r * x + $c)
    end
    :(function (x::$T)
        $r
    end)
end</code></pre><p>This function also uses a recursion to grow the expression, creating somewhat pretier code.</p><pre><code class="language-julia hljs">using MacroExercises.Polynomials: horner

Base.remove_linenums!(
    horner(Polynomial(1.0, 0.5, 0.333, 0.25)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">:(function (x::Float64,)
      ((0.25x + 0.333) * x + 0.5) * x + 1.0
  end)</code></pre><p>So, how do they compare?</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MacroExercises.Polynomials: Polynomial, expand, horner</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: Package BenchmarkTools not found in current path:
- Run `import Pkg; Pkg.add(&quot;BenchmarkTools&quot;)` to install the BenchmarkTools package.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = Polynomial((1.0 ./ factorial.(0:11))...)</code><code class="nohighlight hljs ansi" style="display:block;">MacroExercises.Polynomials.Polynomial{Float64}([1.0, 1.0, 0.5, 0.16666666666666666, 0.041666666666666664, 0.008333333333333333, 0.001388888888888889, 0.0001984126984126984, 2.48015873015873e-5, 2.7557319223985893e-6, 2.755731922398589e-7, 2.505210838544172e-8])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs = collect(LinRange(0.0, 1.0, 1000))  # make sure to collect</code><code class="nohighlight hljs ansi" style="display:block;">1000-element Vector{Float64}:
 0.0
 0.001001001001001001
 0.002002002002002002
 0.003003003003003003
 0.004004004004004004
 0.005005005005005005
 0.006006006006006006
 0.007007007007007007
 0.008008008008008008
 0.009009009009009009
 ⋮
 0.991991991991992
 0.992992992992993
 0.993993993993994
 0.994994994994995
 0.995995995995996
 0.996996996996997
 0.997997997997998
 0.998998998998999
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_unroll = eval(expand(f))</code><code class="nohighlight hljs ansi" style="display:block;">#1 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_unroll(1.0)  # should be close to e</code><code class="nohighlight hljs ansi" style="display:block;">2.718281826198493</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_horner = eval(horner(f))</code><code class="nohighlight hljs ansi" style="display:block;">#3 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f_horner(1.0)</code><code class="nohighlight hljs ansi" style="display:block;">2.718281826198493</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark xs .|&gt; f_unroll</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: LoadError: UndefVarError: @benchmark not defined
in expression starting at REPL[9]:1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark xs .|&gt; f_horner</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: LoadError: UndefVarError: @benchmark not defined
in expression starting at REPL[10]:1</code></pre><p>I don&#39;t know what this benchmark will do on the Github servers, but on my laptop this gives 1.466μs and 1.346μs minimum runtime. So Horner&#39;s method gives me close to 10% speed-up. Let&#39;s compare this with the C++ code, using a better benchmarking tool (<code>google-benchmark</code> in this case)!</p><p>The difference is a bit less than my previous amateurish attempt at a benchmark, but a real difference is still there: 1.692μs for Horner&#39;s method.</p><div class="noweb-label">file:<i>src/horner.cpp</i></div><pre><code class="language- cpp hljs">#include &lt;benchmark/benchmark.h&gt;
#include &lt;vector&gt;

constexpr unsigned ORDER = 11;
constexpr unsigned N = 1000;

double polynome(std::vector&lt;double&gt; const &amp;cs, double x) {
    double r = cs.front();
    double xp = x;
    for (unsigned i = 1; i &lt; cs.size() - 1; ++i) {
        r += xp * cs[i];
        xp *= x;
    }
    r += xp * cs.back();
    return r;
}

double horner(std::vector&lt;double&gt; const &amp;cs, double x) {
    double r = cs.back();
    for (unsigned i = 1; i &lt; cs.size(); ++i)
        r = r * x + cs[cs.size() - 1 - i];
    return r;
}

struct BMSetup {
    std::vector&lt;double&gt; xs, ys;
    std::vector&lt;double&gt; cs;

    BMSetup(): xs(N), ys(N), cs(ORDER+1) {
        for (unsigned i = 0; i &lt; N; ++i)
            xs[i] = i / double(N);
        unsigned j = 1;
        cs[0] = 1.0;
        for (unsigned i = 1; i &lt; ORDER+1; ++i, j *= i)
            cs[i] = 1.0 / double(j);
    }
};

static void bm_horner(benchmark::State &amp;state) {
    BMSetup setup{};
    for (auto _ : state) {
        for (unsigned i = 0; i &lt; N; ++i) {
            setup.ys[i] = horner(setup.cs, setup.xs[i]);
        }
    }
}

BENCHMARK(bm_horner);

static void bm_polynome(benchmark::State &amp;state) {
    BMSetup setup{};
    for (auto _ : state) {
        for (unsigned i = 0; i &lt; N; ++i) {
            setup.ys[i] = polynome(setup.cs, setup.xs[i]);
        }
    }
}

BENCHMARK(bm_polynome);

BENCHMARK_MAIN();</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Exercises in macro writing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 3 December 2022 22:20">Saturday 3 December 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
