var documenterSearchIndex = {"docs":
[{"location":"polynomials/#Polynomials","page":"Polynomials","title":"Polynomials","text":"","category":"section"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"If you're not sold on macros for their expressiveness, here's something new for you. One reason why macros can be so powerful, is that they let us write little code generators for things that we normally wouldn't bother with. This means getting potentially huge performance gains. We'll work through an example where we need to compute some polynomial.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"<div class=\"noweb-label\">file:<i>src/Polynomials.jl</i></div>","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"module Polynomials\n<<polynomials>>\nend","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"A polynomial is a function defined by some finite power series,","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"f(x) = sum_i = 0^n c_i x^i","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"where we refer to c_i as the coefficients of the polynomial. We may store a polynomial as a Vector.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"<div class=\"noweb-label\">⪡polynomials⪢≣</div>","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"struct Polynomial{T}\n    c::Vector{T}\nend\n\nfunction Polynomial(c::T...) where T<:Number\n    Polynomial(T[c...])\nend\n\nfunction compute_vectorized(f::Polynomial{T}, x::T) where T<:Number\n    sum(f.c .* x.^(0:(length(f.c)-1)))\nend","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"The notation in compute_vectorized is very compact, and it closely mimics the actual function definition that we gave for a polynomial. Is it also fast?","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"using MacroExercises.Polynomials: Polynomial, compute_vectorized, compute_tight_loop\n\nf = Polynomial(1.0, -3.0, 2.0, -4.0, 1.5, 0.3, -0.1)\nxs = LinRange(0.0, 1.0, 100000)\n\ntest_f1(n) = for _ in 1:n\n    xs .|> x -> compute_vectorized(f, x)\nend\n\n# compile\ntest_f1(1)\n\n# time\n@elapsed test_f1(100)","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"On my machine this takes about two seconds. A profiler reveals that most time (about 70%) is spent computing the :^ function. We can be more efficient if we use incremental multiplication.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"<div class=\"noweb-label\">⪡polynomials⪢⊞</div>","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"function compute_tight_loop(f::Polynomial{T}, x::T) where T<:Number\n    result = 0\n    xpow = 1\n    for c in f.c\n        result += xpow * c\n        xpow *= x\n    end\n    result\nend","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"test_f2(n) = for _ in 1:n\n    xs .|> x -> compute_tight_loop(f, x)\nend\n\ntest_f2(1)\n\n@elapsed test_f2(1000)","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"This takes about three seconds on my machine, so the tight loop version is an order of magnitude faster (note the sample size). Can we do better? Now it starts to get interesting! We'll generate code as if we unroll the for-loop for a specific case of a polynomial manualy.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"<div class=\"noweb-label\">⪡polynomials⪢⊞</div>","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"function expand(f::Polynomial{T}) where T<:Number\n    :(function (x::$T)\n        r = $(f.c[1])\n        xp = x\n        $((:(r += xp*$c; xp*=x) for c in f.c[2:end-1])...)\n        r + xp * $(f.c[end])\n    end)\nend","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"What does that generated code look like?","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"using MacroExercises.Polynomials: Polynomial, expand\n\nBase.remove_linenums!(\n    expand(Polynomial(1.0, 0.5, 0.333, 0.25)))","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"Now, test it for speed:","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"f_unroll = eval(expand(f))\ntest_f3(n) = sum(sum(f_unroll.(xs)) for _ in 1:n)\ntest_f3(1)\n@elapsed test_f3(1000)","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"For me this computes in 0.12 seconds. That is 25 times faster than the dynamic tight_loop version. I think that is really amazing. For reference, here is the C++ equivalent of the tight loop version. I had to try really hard to make it not optimize away results that weren't used afterwards.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"<div class=\"noweb-label\">file:<i>src/polynomials.cpp</i></div>","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"#include <vector>\n#include <iostream>\n#include <chrono>\n#include <algorithm>\n#include <numeric>\n\ndouble compute_tight_loop(std::vector<double> const &cs, double x) {\n    double r = 0.0;\n    double xp = 1.0;\n    for (auto c : cs) {\n        r += xp * c;\n        xp *= x;\n    }\n    return r;\n}\n\nint main() {\n    using std::chrono::duration_cast;\n    using std::chrono::milliseconds;\n    using std::accumulate;\n\n    std::vector<double> c{1.0, -3.0, 2.0, -4.0, 1.5, 0.3, -0.1};\n    std::cout << compute_tight_loop(c, 10.0) << std::endl;\n    std::vector<double> input(100000), output(100000);\n    for (unsigned i = 0; i < 100000; ++i) { input[i] = i / 100000.0; }\n    auto start = std::chrono::high_resolution_clock::now();\n    double grant_total = 0.0;\n    for (unsigned i = 0; i < 1000; ++i) {\n        for (unsigned j = 0; j < 100000; ++j) { output[j] = compute_tight_loop(c, input[j]); }\n        grant_total += accumulate(output.begin(), output.end(), 0.0);\n    }\n    auto stop = std::chrono::high_resolution_clock::now();\n    std::cout << \"total: \" << grant_total << std::endl\n              << \"duration: \" << duration_cast<milliseconds>(stop - start) << std::endl;\n    return 0;\n}","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"This gives me about 300ms on my laptop, against 120ms for the Julia version. So how could Julia be faster than C++? We were able to compile our polynomial code for a specific polynomial on the fly, creating a function that does not need to access memory. The equivalent in C++ would be to generate code and pass that through GCC and then run it: that is insane.","category":"page"},{"location":"polynomials/#Horner's-method","page":"Polynomials","title":"Horner's method","text":"","category":"section"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"There is a more efficient way to evaluate a polynomial, called Horner's method (thanks Nicos Pitsianis for pointing it out to me). Let's implement it and compare. The method works by starting at the highest order coefficient.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"<div class=\"noweb-label\">⪡polynomials⪢⊞</div>","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"function horner(f::Polynomial{T}) where T<:Number\n    r = :($(f.c[end]))\n    for c in reverse(f.c[1:end-1])\n        r = :($r * x + $c)\n    end\n    :(function (x::$T)\n        $r\n    end)\nend","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"This function also uses a recursion to grow the expression, creating somewhat pretier code.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"using MacroExercises.Polynomials: horner\n\nBase.remove_linenums!(\n    horner(Polynomial(1.0, 0.5, 0.333, 0.25)))","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"So, how do they compare?","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"using MacroExercises.Polynomials: Polynomial, expand, horner\nusing BenchmarkTools\nf = Polynomial((1.0 ./ factorial.(0:11))...)\nxs = collect(LinRange(0.0, 1.0, 1000))  # make sure to collect\nf_unroll = eval(expand(f))\nf_unroll(1.0)  # should be close to e\nf_horner = eval(horner(f))\nf_horner(1.0)\n@benchmark xs .|> f_unroll\n@benchmark xs .|> f_horner","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"I don't know what this benchmark will do on the Github servers, but on my laptop this gives 1.466μs and 1.346μs minimum runtime. So Horner's method gives me close to 10% speed-up. Let's compare this with the C++ code, using a better benchmarking tool (google-benchmark in this case)!","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"The difference is a bit less than my previous amateurish attempt at a benchmark, but a real difference is still there: 1.692μs for Horner's method.","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"<div class=\"noweb-label\">file:<i>src/horner.cpp</i></div>","category":"page"},{"location":"polynomials/","page":"Polynomials","title":"Polynomials","text":"#include <benchmark/benchmark.h>\n#include <vector>\n\nconstexpr unsigned ORDER = 11;\nconstexpr unsigned N = 1000;\n\ndouble polynome(std::vector<double> const &cs, double x) {\n    double r = cs.front();\n    double xp = x;\n    for (unsigned i = 1; i < cs.size() - 1; ++i) {\n        r += xp * cs[i];\n        xp *= x;\n    }\n    r += xp * cs.back();\n    return r;\n}\n\ndouble horner(std::vector<double> const &cs, double x) {\n    double r = cs.back();\n    for (unsigned i = 1; i < cs.size(); ++i)\n        r = r * x + cs[cs.size() - 1 - i];\n    return r;\n}\n\nstruct BMSetup {\n    std::vector<double> xs, ys;\n    std::vector<double> cs;\n\n    BMSetup(): xs(N), ys(N), cs(ORDER+1) {\n        for (unsigned i = 0; i < N; ++i)\n            xs[i] = i / double(N);\n        unsigned j = 1;\n        cs[0] = 1.0;\n        for (unsigned i = 1; i < ORDER+1; ++i, j *= i)\n            cs[i] = 1.0 / double(j);\n    }\n};\n\nstatic void bm_horner(benchmark::State &state) {\n    BMSetup setup{};\n    for (auto _ : state) {\n        for (unsigned i = 0; i < N; ++i) {\n            setup.ys[i] = horner(setup.cs, setup.xs[i]);\n        }\n    }\n}\n\nBENCHMARK(bm_horner);\n\nstatic void bm_polynome(benchmark::State &state) {\n    BMSetup setup{};\n    for (auto _ : state) {\n        for (unsigned i = 0; i < N; ++i) {\n            setup.ys[i] = polynome(setup.cs, setup.xs[i]);\n        }\n    }\n}\n\nBENCHMARK(bm_polynome);\n\nBENCHMARK_MAIN();","category":"page"},{"location":"#Exercises-in-macro-writing","page":"Exercises in macro writing","title":"Exercises in macro writing","text":"","category":"section"},{"location":"","page":"Exercises in macro writing","title":"Exercises in macro writing","text":"(Image: Entangled badge)","category":"page"},{"location":"","page":"Exercises in macro writing","title":"Exercises in macro writing","text":"These are some exercises in meta-programming in Julia. I made these to make myself familiar with Julia symbolic expressions and macro system. ","category":"page"},{"location":"#Literate-programming","page":"Exercises in macro writing","title":"Literate programming","text":"","category":"section"},{"location":"","page":"Exercises in macro writing","title":"Exercises in macro writing","text":"I use a system of literate programming called Entangled. Many of the code blocks you see in this document end up in the actual source code for the modules that I use in the examples.","category":"page"},{"location":"","page":"Exercises in macro writing","title":"Exercises in macro writing","text":"<div class=\"noweb-label\">file:<i>src/MacroExercises.jl</i></div>","category":"page"},{"location":"","page":"Exercises in macro writing","title":"Exercises in macro writing","text":"module MacroExercises\n\ninclude(\"Polynomials.jl\")\n\nend","category":"page"},{"location":"#Contents","page":"Exercises in macro writing","title":"Contents","text":"","category":"section"},{"location":"","page":"Exercises in macro writing","title":"Exercises in macro writing","text":"","category":"page"}]
}
